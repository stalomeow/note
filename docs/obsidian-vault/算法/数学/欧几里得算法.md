---
slug: "240527191628"
date: 2024-05-27
---

# 欧几里得算法

又叫辗转相除法，用于求两数的最大公约数（Greatest common divisor）。

## 引理

不妨设 $a > b$，这个算法的基础是

$$
\gcd(a,b)=\gcd(b, a \bmod b)
$$

由于 $a > b$，假设

$$
a=bq+(a \bmod b), q \in \mathbb{Z}
$$

设 $a$ 和 $b$ 的公约数为 $c$，根据[[整除]]的性质有

$$
c \mid a \wedge c \mid b \Longrightarrow c \mid (a-bq)
$$
这说明 $a$ 和 $b$ 的所有公约数也是 $b$ 和 $a \bmod b$ 的公约数。

反过来，设 $b$ 和 $a \bmod b$ 的公约数为 $c$，根据[[整除]]的性质也有

$$
c \mid b \wedge c \mid (a \bmod b) \Longrightarrow c \mid (bq+(a \bmod b))
$$

这说明 $b$ 和 $a \bmod b$ 的所有公约数也是 $a$ 和 $b$ 的公约数。

==所以，$a, b$ 的公约数和 $b,(a \bmod b)$ 的公约数都是一样的，那最大公约数也是一样。==

## 递归实现

利用上面的性质不断递归，直到 $b$ 变成 $0$。这时候，上一轮 $a \bmod b = 0$，即 $b \mid a$，最大公约数肯定是 $b$（这一轮的 $a$）。

暂时不考虑负数。

``` c
int gcd(int a, int b)
{
    return b == 0 ? a : gcd(b, a % b);
}
```

这个函数不要求 $a>b$，因为如果 $a<b$ 的话，就会递归调用 $\gcd(b,a)$。


## 迭代实现

``` c
int gcd(int a, int b)
{
    while (b != 0)
    {
        int tmp = a;
        a = b;
        b = tmp % b;
    }
    return a;
}
```


## 时间复杂度


