/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ImageCaptions,
  renderMarkdown: () => renderMarkdown
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var filenamePlaceholder = "%";
var filenameExtensionPlaceholder = "%.%";
var ImageCaptions = class extends import_obsidian.Plugin {
  async onload() {
    this.registerMarkdownPostProcessor(externalImageProcessor(this));
    this.observer = new MutationObserver((mutations) => {
      mutations.forEach((rec) => {
        if (rec.type === "childList") {
          rec.target.querySelectorAll(".image-embed").forEach(async (imageEmbedContainer) => {
            var _a, _b;
            const img = imageEmbedContainer.querySelector("img");
            const width = imageEmbedContainer.getAttribute("width") || "";
            const captionText = getCaptionText(imageEmbedContainer);
            if (!img)
              return;
            const figure = imageEmbedContainer.querySelector("figure");
            const figCaption = imageEmbedContainer.querySelector("figcaption");
            if (figure || ((_a = img.parentElement) == null ? void 0 : _a.nodeName) === "FIGURE") {
              if (figCaption && captionText) {
                const children = (_b = await renderMarkdown(captionText, "", this)) != null ? _b : [captionText];
                figCaption.replaceChildren(...children);
              } else if (!captionText) {
                imageEmbedContainer.appendChild(img);
                figure == null ? void 0 : figure.remove();
              }
            } else {
              if (captionText && captionText !== imageEmbedContainer.getAttribute("src")) {
                await insertFigureWithCaption(img, imageEmbedContainer, captionText, "", this);
              }
            }
            if (width) {
              img.setAttribute("width", width);
            } else {
              img.removeAttribute("width");
            }
          });
        }
      });
    });
    this.observer.observe(document.body, { subtree: true, childList: true });
  }
  onunload() {
    this.observer.disconnect();
  }
};
function getCaptionText(img) {
  let captionText = img.getAttribute("alt") || "";
  const src = img.getAttribute("src") || "";
  if (captionText === src) {
    captionText = "";
  } else if (captionText === filenamePlaceholder) {
    const match = src.match(/[^\\\/]+(?=\.\w+$)|[^\\\/]+$/);
    if (match == null ? void 0 : match[0]) {
      captionText = match[0];
    }
  } else if (captionText === filenameExtensionPlaceholder) {
    const match = src.match(/[^\\\/]+$/);
    if (match == null ? void 0 : match[0]) {
      captionText = match[0];
    }
  } else if (captionText === "\\" + filenamePlaceholder) {
    captionText = filenamePlaceholder;
  }
  captionText = captionText.replace(/<<(.*?)>>/g, (match, linktext) => {
    return "[[" + linktext + "]]";
  });
  return captionText;
}
function externalImageProcessor(plugin) {
  return (el, ctx) => {
    el.findAll("img:not(.emoji)").forEach(async (img) => {
      const captionText = getCaptionText(img);
      const parent = img.parentElement;
      if (parent && (parent == null ? void 0 : parent.nodeName) !== "FIGURE" && captionText && captionText !== img.getAttribute("src")) {
        await insertFigureWithCaption(img, parent, captionText, ctx.sourcePath, plugin);
      }
    });
  };
}
async function insertFigureWithCaption(imageEl, outerEl, captionText, sourcePath, plugin) {
  var _a;
  const figure = outerEl.createEl("figure");
  figure.addClass("image-captions-figure");
  figure.appendChild(imageEl);
  const children = (_a = await renderMarkdown(captionText, sourcePath, plugin)) != null ? _a : [captionText];
  figure.createEl("figcaption", {
    cls: "image-captions-caption"
  }).replaceChildren(...children);
}
async function renderMarkdown(markdown, sourcePath, component) {
  const el = createDiv();
  await import_obsidian.MarkdownRenderer.renderMarkdown(markdown, el, sourcePath, component);
  for (const child of el.children) {
    if (child.tagName == "P") {
      return child.childNodes;
    }
  }
}
