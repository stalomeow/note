---
date: 2024-04-25T23:51:11
---

# 最小生成树

最小生成树（Minimum spanning tree，MST）是最小权重生成树（Minimum weight spanning tree）的简称，是一副连通加权无向图中一棵权值最小的生成树。

## Prim

贪心算法。将结点分为 `u`（已经在生成树内）和 `v`（不在生成树内）两部分，每次从 `v` 中选择离 `u` 集合最近的结点，然后移动至 `u` 中。

1. 初始化邻接表、`dist` 数组、`inMST` 数组
2. 找到 `!inMST[i]` 且 `dist[i]` 最小的 `i`
3. `inMST[i] = true`
4. 遍历与 `i` 相邻的结点 `j`，如果 `!inMST[j]` 则 `dist[j] = min(dist[j], edge[i][j])`

### Lazy

使用优先队列实现。找到 `i` 后不更新 `dist[j]`，直接把新的 `(j, dist[j])` 放到优先队列中。从优先队列中弹出元素 `(k, dist[k])` 后，如果 `!inMST[k]`，对应的 `dist[k]` 一定是队列中所有 `dist[k]` 的最小值；如果 `inMST[k]`，说明这次弹出的是无效值。

``` java
public class LazyPrimMST {
    private final EdgeWeightedGraph graph;
    private double weight;                // 记录最小生成树的总权重
    private final Queue<Edge> mst;        // 存储最小生成树的边
    private final boolean[] marked;       // 标记这个顶点在树中
    private final PriorityQueue<Edge> pq; // 存储横切边的优先队列

    public LazyPrimMST(EdgeWeightedGraph graph) {
        this.graph = graph;
        int vertex = graph.vertex();
        mst = new ArrayDeque<>();
        pq = new PriorityQueue<>();
        marked = new boolean[vertex];

        for (int v = 0; v < vertex; v++)
            if (!marked[v]) prim(v);
    }

    private void prim(int s) {
        scanAndPushPQ(s);
        while (!pq.isEmpty()) {
            Edge edge = pq.poll();  // 取出权重最小的横切边
            int v = edge.either(), w = edge.other(v);  
            assert marked[v] || marked[w];

            if (marked[v] && marked[w])
                continue; // 忽略失效边

            mst.add(edge); // 添加边到最小生成树中
            weight += edge.weight(); // 更新总权重
			// 继续将非树顶点加入到树中并更新横切边
            if (!marked[v]) scanAndPushPQ(v); 
            if (!marked[w]) scanAndPushPQ(w); 
        }
    }

    // 标记顶点到树中,并且添加横切边到优先队列
    private void scanAndPushPQ(int v) {
        assert !marked[v];
        marked[v] = true;
        for (Edge e : graph.adj(v))
            if (!marked[e.other(v)]) pq.add(e);
    }

    public Iterable<Edge> edges() {
        return mst;
    }

    public double weight() {
        return weight;
    }
}
```

- 空间复杂度：$O(E)$
- 时间复杂度：$O(E \log E)$

### Eager

## Kruskal

贪心算法。

根据权值从小到大加入边，如果加入这条边会产生环，则丢弃这条边。

可以用优先队列（或数组 + 排序）来存边，用并查集来维护两节点的连通关系。如果某条边的两节点之前就已经连通，那么加入这条边就会产生环，需要丢弃这条边。

时间复杂度 $O(n \log n)$，$n$ 是边的数量。
