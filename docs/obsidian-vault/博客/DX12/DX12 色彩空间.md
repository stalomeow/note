---
date: 2024-10-20T01:10:44
slug: dx12-color-space
categories:
  - 图形渲染
  - 引擎开发
  - DirectX
  - ImGui
  - RenderDoc
draft: false
comments: true
---

# DX12 色彩空间

<!-- more -->

Unity 中有 Linear 和 Gamma 两种 Color Space，为了计算更准确，现在都用 Linear。自己写引擎时，需要一些特殊处理才能在 Linear Space 里渲染。

## Gamma

Gamma 是一个非线性变换，一般定义为

$$
V_{\text{out}} = A V_{\text{in}}^\gamma
$$

通常情况下，$A=1$ 且输入和输出都在 $[0,1]$ 范围

- $0 < \gamma < 1$ 时，称为 Gamma 压缩、Gamma 校正。
- $\gamma > 1$ 时，称为 Gamma 展开、去 Gamma 校正。

### 显示器

早期的阴极射线管显示器（CRT Display）输出亮度 $I$ 与输入电压 $u$ 的关系为

$$
I=u^{\gamma}
$$

其中 $\gamma > 1$。所以，要对输入信号做一次 Gamma 校正

$$
u_{\text{o}} = u_{\text{i}}^{1/\gamma}
$$

才能将输入正确地显示出来。

### 图像编码

人眼感知到的亮度 $I_1$ 和物理世界的亮度 $I_2$ 大致也有一个指数关系

$$
I_1 = I_2^{\gamma}
$$

其中 $\gamma > 1$。这个公式和 CRT 显示器的很像，但这只是个巧合。从公式可以看出，当 $I_2$ 较小时，$I_1$ 变化得较慢。换句话说，人眼能感知到更多暗色的变化，所以在编码图像时，应该给暗色更高的精度。

| 编码    | 原理                                               | 是否需要 Gamma                                                                |
| :---- | :----------------------------------------------- | ------------------------------------------------------------------------- |
| UNORM | 用 n 位无符号整数表示小数 0.0 - 1.0，整数 $x$ 表示小数 $x/(2^n-1)$ | 在将 0.0 - 1.0 的颜色值编码为整数前，应该先进行 Gamma 校正，把暗色的范围变大，使得编码后有更多整数表示暗色，更多地保留暗色的变化 |
| FLOAT | IEEE-754 或类似表示方法                                 | 没必要，可能还会起反作用 [^1]                                                         |

## CIE XYZ

这就是所谓的 Linear Color Space。颜色的三维坐标（X、Y、Z）与物理光能量之间是线性关系。如果将光源的能量按比例放大或缩小，那么 CIE XYZ 的坐标也会以同样的比例变化。

## sRGB

sRGB 是惠普和微软开发的一种标准 RGB 色彩空间，被广泛使用。

### 公式

$$
C_{\text{linear}} = \begin{cases}
\dfrac{C_\text{srgb}}{12.92}&, C_\text{srgb} \le 0.04045\\
\left (\dfrac{C_\text{srgb} + 0.055}{1.055} \right)^{2.4}&, C_\text{srgb} > 0.04045
\end{cases}
$$

$$
C_\text{srgb}=\begin{cases}
12.92 C_\text{linear}&, C_\text{linear} \le 0.0031308\\
1.055 \left( C_\text{linear}^{1/2.4} \right) - 0.055&, C_\text{linear} > 0.0031308
\end{cases}
$$

指数函数 $x^{1/2.4}$ 在靠近 $0$ 的地方斜率趋于无穷，会放大一些微弱的噪声，所以靠近 $0$ 的地方使用线性函数代替。

### 近似

完整的分段函数比较复杂，通常用 2.2 的 Gamma 近似

$$
C_\text{linear} = C_\text{srgb}^{2.2}
$$

$$
C_\text{srgb} = C_\text{linear}^{1/2.2}
$$

在不特别说明的情况下，大家说的 Gamma 指的都是 sRGB 这个 2.2。sRGB 到 Linear 就是「去 Gamma 校正」，Linear 到 sRGB 就是「Gamma 校正」。

## DXGI_FORMAT

DXGI_FORMAT 中带有 `_SRGB` 后缀的格式表示其保存的是 sRGB 颜色。在 Shader 中采样这些格式的纹理时，会自动将 sRGB 颜色转为 Linear 颜色。在 Shader 中向这些格式的 RTV 渲染时，会默认 `SV_Target` 输出的是 Linear 颜色，然后自动转换为 sRGB 颜色再保存。转换颜色时，使用的是准确的分段公式，而不是 Gamma 2.2 的近似公式。

只有整数格式（UNORM）才有 `_SRGB` 后缀。没有 `_SRGB` 后缀的格式也能保存 sRGB 颜色，只是 Linear 和 sRGB 的转换需要自己进行。

## Swap Chain

| Back Buffer 格式                            | 色彩空间           | 备注                                                                           |
| ----------------------------------------- | -------------- | ---------------------------------------------------------------------------- |
| 整数 `DXGI_FORMAT_*_UNORM`（不能带有 `_SRGB` 后缀） | 必须写入 sRGB 颜色   | 可以创建 `DXGI_FORMAT_*_SRGB` 类型的 RTV，这样就能自动将 `SV_Target` 输出的 Linear 颜色转为 sRGB 了 |
| 浮点数                                       | 必须写入 Linear 颜色 |                                                                              |

表格中创建 RTV 的方法是只适用于 Back Buffer 的特例，其他资源必须创建为 `DXGI_FORMAT_*_TYPELESS` 才能实现。[^2]

## RenderDoc

RenderDoc 的 Texture Viewer 上有个 Gamma 按钮。如果当前查看的纹理内容是 sRGB 的，就选中它，如果内容是 Linear 的，就关闭它。[^3]

## 渲染差异

从数学和物理的角度来看，Gamma (sRGB) Color Space 渲染是不准确的，差异主要体现在光照和透明混合上。[^4] 另外，Linear Space 的渲染看上去会亮一点。

## 实现 Linear Color Space 渲染

### RTV

建议所有中间的临时 RTV 都不带 `_SRGB` 后缀，最后的 Back Buffer RTV 使用 `DXGI_FORMAT_*_SRGB`。这样中间所有内容都在 Linear 空间，只在 Present 前进行一次 Gamma 校正。

### Texture

像 Unity 一样提供一个 `sRGB` 选项，然后使用 DirectXTex 提供的 `CREATETEX_FLAGS` 进行 sRGB 配置。

``` cpp
// https://github.com/microsoft/DirectXTex/wiki/CreateTexture
// The CREATETEX_SRGB flag provides an option for working around gamma issues with content
// that is in the sRGB or similar color space but is not encoded explicitly as an SRGB format.
// This will force the resource format be one of the of DXGI_FORMAT_*_SRGB formats if it exist.
// Note that no pixel data conversion takes place.
// The CREATETEX_IGNORE_SRGB flag does the opposite;
// it will force the resource format to not have the _*_SRGB version.
CREATETEX_FLAGS createFlags;

if constexpr (GfxSettings::GetColorSpace() == GfxColorSpace::Linear)
{
    createFlags = m_IsSRGB ? CREATETEX_FORCE_SRGB : CREATETEX_IGNORE_SRGB;
}
else
{
    // shader 中采样时不进行任何转换
    createFlags = CREATETEX_IGNORE_SRGB;
}

GFX_HR(CreateTextureEx(device, m_MetaData, D3D12_RESOURCE_FLAG_NONE, createFlags, &m_Resource));
```

### Color

我们平时说的颜色值、Editor 里配置的颜色都是 sRGB 空间的。从外部向 Shader 传入颜色时（例如 Material Constant Buffer），需要将颜色从 sRGB 空间转到 Linear 空间。

### ImGui

ImGui 目前所有操作都是在 sRGB 空间进行的，不支持 Linear Color Space。[^5] 考虑到透明混合的问题，不能直接把 ImGui 传入 Shader 的颜色转到 Linear 空间，否则在不同 Color Space 下 ImGui 看上去不一致，尤其是它的 Color Picker。

注意到 ImGui 只有一张 Texture，在不使用 [Colorful Glyphs/Emojis](https://github.com/ocornut/imgui/blob/master/docs/FONTS.md#using-colorful-glyphsemojis) 时，这张 Texture 的 RGB 全是 1，这意味着把它当成 Linear 颜色变换到 sRGB 或者反过来结果都一样。我引擎的 Texture 在被 Shader 采样后得到的都是 Linear 颜色，所以不妨把 ImGui 的 Texture 当成 Linear Texture。

修改 ImGui 的 Pixel Shader，把 Texture 的采样结果变换到 sRGB 空间，使得 ImGui 依旧在 sRGB 空间渲染。

``` hlsl
struct PS_INPUT
{
  float4 pos : SV_POSITION;
  float4 col : COLOR0;
  float2 uv  : TEXCOORD0;
};
SamplerState sampler0 : register(s0);
Texture2D texture0 : register(t0);

float LinearToSRGB1(float x)
{
    return (x < 0.0031308) ? (12.92 * x) : (1.055 * pow(x, 1.0 / 2.4) - 0.055);
}
float3 LinearToSRGB3(float3 x)
{
    return float3(LinearToSRGB1(x.r), LinearToSRGB1(x.g), LinearToSRGB1(x.b));
}
float4 main(PS_INPUT input) : SV_Target
{
  float4 tex_col = texture0.Sample(sampler0, input.uv);
  float4 out_col = input.col * float4(LinearToSRGB3(tex_col.rgb), tex_col.a);
  return out_col;
}
```

等 ImGui 渲染完成后，将 sRGB 颜色转到 Linear 空间，同时 Blit 到 Back Buffer（sRGB RTV）。

``` cpp
void GameEditor::DrawImGuiRenderGraph(GfxDevice* device, int32_t renderTargetId)
{
    auto builder = m_ImGuiRenderGraph->AddPass("DrawImGui");

    GfxRenderTextureDesc desc = device->GetBackBuffer()->GetDesc();
    desc.Format = m_ImGuiRtvFormat;

    builder.CreateTransientTexture(renderTargetId, desc);
    builder.SetRenderTargets(renderTargetId);
    builder.ClearRenderTargets(ClearFlags::Color);

    builder.SetRenderFunc([=](RenderGraphContext& context)
    {
        ImGui::Render();
        ImGui_ImplDX12_RenderDrawData(ImGui::GetDrawData(), context.GetD3D12GraphicsCommandList());
    });
}

void GameEditor::BlitImGuiToBackBuffer(GfxDevice* device, int32_t srcTextureId, int32_t backBufferId)
{
    auto builder = m_ImGuiRenderGraph->AddPass("BlitImGuiToBackBuffer");

    builder.ImportTexture(backBufferId, device->GetBackBuffer());
    builder.SetRenderTargets(backBufferId);

    TextureHandle srcTexture = builder.ReadTexture(srcTextureId, ReadFlags::PixelShader);

    builder.SetRenderFunc([=](RenderGraphContext& context)
    {
        m_BlitImGuiMaterial->SetTexture("_SrcTex", srcTexture.Get());
        context.DrawMesh(GetFullScreenTriangleMesh(), m_BlitImGuiMaterial.get());
    });
}
```

``` hlsl
float4 c = _SrcTex.Sample(sampler_SrcTex, input.uv);

#ifdef MARCH_COLORSPACE_GAMMA
    return c;
#else
    return SRGBToLinear(c);
#endif
```

[^1]: [Gamma correction - Wikipedia](https://en.wikipedia.org/wiki/Gamma_correction)
[^2]: [Converting data for the color space - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/direct3ddxgi/converting-data-color-space#color-accuracy)
[^3]: [Tip #12 - Linear/Gamma display of textures (renderdoc.org)](https://renderdoc.org/tips/12)
[^4]: [Unity - Manual: Linear or gamma workflow (unity3d.com)](https://docs.unity3d.com/2022.3/Documentation/Manual/LinearRendering-LinearOrGammaWorkflow.html)
[^5]: [sRGB and linear color spaces · Issue #578 · ocornut/imgui (github.com)](https://github.com/ocornut/imgui/issues/578)
